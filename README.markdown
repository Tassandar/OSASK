## 30天自制操作系统 ------  OSASK


这是川合秀实的[《30天自制操作系统》](http://book.douban.com/subject/11530329/)的git管理版本。你可以轻易地用git来对其进行管理，建立分支，增减功能，进而做成自己的更为复杂的操作系统。

另外，因为是新手向的书，书中有大量的很简单的概念，为了大家阅读和学习方便，我将每一天所完成的内容作了一个整理，并用中文对一些比较复杂的内容作出了注释。

OK，向着属于你的操作系统进发吧！

### 为什么要用git管理我的操作系统

谁都知道，学习编程的唯一捷径就是多写多练，与其把书上的代码都敲到电脑里面去，不如在阅读与理解全书之后对操作系统进行力所能及的改进与扩展。而这时候很烦人的事情出现了，你常常无法了解到，一个层层叠叠的系统中，自己要修改的部分究竟是如何堆叠起来的，自己要修改的部分究竟和那几个组件出现了耦合。

这时候代码管理工具就帮上忙了，git
是一个十分优秀的代码管理工具。你可以看到每一天的进度和完成的内容，可以轻松地通过git的变基，分支，检出操作来对操作系统作出修改，扩展或测试，而无需担心自己会破坏或搞烂原本的代码。

通过git历史，你还能够清楚地看到，操作系统每一天修改了那些代码，让自己心里有数。

欢迎大家通过github上传自己写出的增强版本OSASK。

#### 如何操作？

1.下载该项目 

		git clone https://github.com/Tassandar/OSASK 

2.查看提交记录
		
		cd OSASK
		git log --graph --pretty=oneline

=> 找到自己需要的代码

		........
		* 8981d2d02d36bbf9954f0c3c20532bd04732e5b8 DAY17
		* bbadc07d81996f13b699f34c93277c3d92d3b4f5 DAY16
		* 2f47672c7b9ac07c0ddf2696d9fa79d81d19e9c4 DAY15
		* b4623d7581b8f5096667723b696f13bad6d460a2 DAY14
		* 72582ea4e7d3631ef10b57bdcbaa59db3893f3f8 DAY13
		* 63e2206785e59869d95415b1033778139f410516 DAY12
		* d09c762b18ee47b601994c7a3e85fd62b2d4e91f DAY11
		* 9b2998c9ff8a73f200d77a9a76bfb1b9c86490e2 DAY10
		........

3.创建自己的分支(只需要ID的前几位就行，这里检出DAY17)

		git branch mybranch 8981d  
  切换到自己的分支（切换后目录下就只出现DAY17版本的内容了，方便使用）  

		git checkout mybranch  

4.run it

打开  !cons_nt.bat
运行  `make run`
done

### 进度条

#### DAY1

使用汇编完成了 helloos.nas ,经过 asm 生成二进制文件 helloos.img,使用　QEMU　软件模拟　PC　输出　hello world 。

#### DAY2

加入makefile。制作启动区。
汇编写出 helloos.nas , asm 后输出 ipl.bin/ipl.lst, 用磁盘映像管理工具 edimg.exe 生成helloos.img.

#### DAY3

制作启动区（从软盘读取数据填充到内存的对应位置），汇编写出一个简易的操作系统（黑屏），用c语言写出停止函数,用汇编写出停止的底层实现，用作者实现的编译器编译后三者链接后输出二进制磁盘映像交由系统启动。

#### DAY4

用汇编实现对显存和中断标志的io，C语言实现绘图，调色函数，在main函数中实现绘制系统框架图。编译链接后交由系统运行。

#### DAY5 

用 struct （结构体） 存储显存信息，加入字体文件hankaku.txt，C语言绘制鼠标图形，加入字符显示函数，引入GDT（全局段号记录表）和IDT（中断记录表），利用结构体和C语言实现读写 GDT 和 IDT 。

#### DAY6

将源文件分割成多个文件，重复部分整理至共有的头文件中。利用通配符简化makefile，设定PIC（可编程中断控制器），C语言实现鼠标键盘中断处理函数，汇编将中断函数处理包装（中断返回，中断标志置位）后注册至IDT。

#### DAY7

完善键盘中断处理，加入键盘输入缓存（FIFO BUF），利用环形队列实现结构体 KEYBUF， 整理至 FIFO.C 文件中；加入鼠标控制电路初始化代码，加入鼠标数据取得方法与中断反馈代码（和键盘类似）。

#### DAY8

加入鼠标数据处理与解读（读取鼠标数据【3连字节】，验证，转换为坐标/状态/按钮值），鼠标移动（频繁擦除重画鼠标ico）。解释了asmhead.nas头文件内容。

#### DAY9

对源文件分割整理，加入高速缓存检测，内存检测，内存管理（将每一段空闲内存记录在特定内存空间中并用结构体存储记录。）

#### DAY10

增强内存管理功能（完善memman_alloc 和  memman_free ，以大区块进行内存分配和释放）。加入叠加处理（加入图层），图像刷新（从底向高层依次绘制图层），图层移动，图层释放，范围刷新技术（以提高图像绘制的速度）。

#### DAY11

支持鼠标移出屏幕（解决刷新溢出），改善图层修改函数，绘制窗口图像，利用制作图层map消除刷新闪烁。

#### DAY12

定时器设置，设置PIT(可编程定时器)，设置中断，定时器函数，管理定时器，加快优化定时器中断处理速度。3秒和10秒时输出屏幕。

#### DAY13

整理简化字符串显示函数，利用定时器改善和调整FIFO缓冲区，定时器性能测试，用链表结构管理定时器，增加定时器哨兵。

#### DAY14

改进性能测试，高分辨率支持（需要转换到真机上运行），键盘输入，输入输出至窗口。制作字符框，鼠标拖动窗口功能。

#### DAY15

多任务处理，定义任务状态段，任务切换功能，测试多任务运算速度，运行测试（让TASK A 和 Task B 轮流数数）。

#### DAY16

任务管理（用结构体记录和管理任务），任务的休眠与唤醒，增加窗口数量（每一任务一个窗口），任务优先级设置。

#### DAY17

对闲置任务的管理（把闲置任务置于最底层），制作命令行窗口，窗口切换（设定为TAB按键），命令行接受键盘数据。符号的输入（感叹号和百分号），实现大小写输入（按键编码与字符编码转换表），对各种锁定键的支持，点亮和熄灭键盘指示灯。

#### DAY18

控制焦点窗口的光标闪烁，命令行支持回车键，对窗口滚动的支持，编写与实现mem,dir命令。

#### DAY19

加入type命令（就是linux中的cat命令），支持FAT(文件分配表)，写出第一个系统程序（让电脑死机。。。）。

#### DAY20

整理程序，制作系统应用程序接口（API），显示字符的API。

#### DAY21

保护操作系统关键段，用C语言写作操作系统API，对异常的支持。

#### DAY22

加强系统保护（防止API被修改），对于程序中溢出的异常处理，强制结束键（强制结束死循环的程序），C语言显示字符串API，窗口显示API。

#### DAY23

重写malloc的API,加入对窗口中图形绘制的API（点，指点，窗口，刷新与关闭窗口）,键盘输入API，强制结束后关闭窗口，WALK小游戏（能控制在窗口上下左右移动的点）。

#### DAY24

窗口切换（使用按键F11，或鼠标点击），鼠标拖动窗口移动，关闭窗口，定时器API。

#### DAY25

蜂鸣器（需要真机运行），增加调色盘（把颜色API改为256色），改进256色至真彩色，支持同时开启多个（最多10个）命令行窗口（新窗口继承原窗口变量，重新分配内存，和fork有点类似），去掉开机自带的小窗口。

#### DAY26

提高窗口拖动速度，启动时打开一个命令行窗口（编写开命令行窗口函数，用shift + F2，打开新命令行窗口），取消命令行数量限制。关闭命令行后进行内存回收。ncst命令（启动程序不打开命令行窗口），start命令（打开一个新的命令行窗口）。

#### DAY27

修复点“x”无法关闭窗口的小bug，保护应用程序，整理源代码。

#### DAY28

alloca(对esp做减法的函数)，文件操作API,命令行API，日文的文字显示。

#### DAY29 & DAY30

这两天都是在做应用程序，主要是代码，讲解很少，就合起来写了，notrec(非矩阵窗口)，bball(画球)，invader(外星人游戏,就是小蜜蜂），tek_getseze & tek_decomp(文件压缩，制作成tek格式),calc(计算器),tview(文本阅览),mmlplay(音乐播放器),gview(图片阅览).


### 川合堂许可协议 
                                                    

#### 概要

  通俗地说：“这是自由软件，使用前使用后都无须支付任何费用，可以自由使用，也可以
复制、修改，以及用于商业目的，但是作者对软件的bug以及因此所造成的损失不负任何责
任。”

  为了保护软件使用者以及软件修改者、参考者的利益，即便作者将来为该软件中所使用的
算法申请专利，也保证不会向使用者收取授权费用。

#### 目的

  适用于本协议的软件，旨在为公众带来利益，以及为软件技术的进步做出贡献。

#### 宗旨

  本协议并不代表作者放弃著作权（仅放弃独家复制发布的权利），使用者可以自由复制并
再次发布本软件的一部分甚至全部内容。使用时无须支付任何费用，对本软件的解析、修改
也无须支付任何费用。

  适用于本协议的软件，可以无条件地用作商业目的，甚至可以将软件直接有偿出售。

  对于以适用于本协议的软件的一部分或全部内容为基础，在此之上所开发的软件（下称“
派生物”），可以赋予任何种类的许可协议。即，派生物的作者可以禁止对派生物进行复制，
也可以只允许派生物以有偿形式发布。派生物的著作权属于该派生物的生成者，适用于本协
议的软件作者不会对其派生物主张著作权。

  在派生物的文档中，没有义务对原始软件的作者进行介绍，但这句话，理所当然地，不意
味着禁止这一行为。

  在发布派生物时，没有义务取得原始软件作者的同意，但这句话，理所当然地，不意味着
禁止这一行为。

  作者不对软件的质量作出任何保证，因此，由于使用本软件所造成的损害，或者没有达到
所期望的结果，作者不负任何责任。

  对于适用于本协议的软件中所使用的技术，除了事先取得作者授权的人以外，禁止其他人
对其申请专利。但如果附加了新的技术并生成了派生物，允许对于追加的部分申请专利。作
者在将来有可能对软件中的技术申请专利，但保证不会向派生物以及软件的使用收取授权费
用。本保证不仅适用于申请专利之前所生成的派生物，也适用于专利取得后所生成的派生物。

  将解析结果汇总并申请专利，需要事先取得作者的同意，但对于申请专利以外的行为，没
有任何限制。

### Links

[川合堂](http://www.imasy.org/~mone/kawaido/)

[kawai](http://www.imasy.org/~kawai/)

[豆瓣图书链接](http://book.douban.com/subject/11530329/)

[OSASK计划](http://http://osask.net/)

[OSASK wiki](http://ja.wikipedia.org/wiki/OSASK)

[source code at sourceforge](http://zh.sourceforge.jp/projects/osask/releases/?package_id=10517)

### Contribute 

欢迎对该项目作出任何形式上的改进，欢迎分享对此开源系统的经验分享。

Just fork me and push to here .


That's it . Have fun.

### License

工具软件中使用的是 

[GNU GPL协议](http://www.gnu.org/licenses/gpl-3.0.html)

[GNU LGPL协议](http://www.gnu.org/licenses/lgpl-3.0.html)
